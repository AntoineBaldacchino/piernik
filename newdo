#!/usr/bin/perl
# $Id$
#
# Usage: makemake {<program name> {<F90 compiler or fc or f77 or cc or c>}}
#
# Generate a Makefile from the sources in the current directory.  The source
# files may be in either C, FORTRAN 77, Fortran 90 or some combination of
# these languages.  If the F90 compiler specified is cray or parasoft, then
# the Makefile generated will conform to the conventions of these compilers.
# To run makemake, it will be necessary to modify the first line of this script
# to point to the actual location of Perl on your system.
#
# Written by Michael Wester <wester@math.unm.edu> February 16, 1995
# Cotopaxi (Consulting), Albuquerque, New Mexico
#
# Modified by Kacper Kowalik <kowalik@astri.umk.pl> October, 24, 2007
# Modified by Dominik Woltanski <minikwolt@astri.umk.pl> April-June, 2008
use Switch;
use File::Path;
use File::Copy;
my $argc = $#ARGV+1;
if($argc < 1){
   print "USAGE: newdo <problem>\n";
   print "Other options:\n";
   print " newdo problems   -  available problems names and their descriptions,\n";
   print " newdo unitsystem -  available unitsystems names and their descriptions,\n";
   print " newdo setup      -  how to run the code instruction,\n";
   print " newdo arrays     -  some important arrays descriptions,\n";
   print " newdo hdf        -  some instruction how to visualize results.\n";
   print " If you want to use the old version type simly 'do' instead of 'newdo'.\n";
   print " Enjoy the new version of Multipiernik!\n";
   print " \n";
#   die;
} else {
if($ARGV[0] eq "problems"){
   print " \n";
   system ( "cat ./problems/*/info");
   print " \n";
} elsif ($ARGV[0] eq "unitsystem"){
   print " \n";
   system ( "grep uses ./src/base/constants.F90");
   print " \n";
} elsif ($ARGV[0] eq "setup"){
   print " \n";
   print "> newdo <problem>  - creating obj directory with necessary source linked inside\n";
   print "> cd obj\n";
   print "# choose Fortran compiler settings (if different than default) typing:\n";
   print "> newcompiler <settingsname>\n";
   print "# modify piernik.def file with precompiler directives and number of fluids if needed\n";
   print "> make\n";
   print "# create run directory where you want\n";
   print "> cp {piernik,problem.par} /<where-you-want>/<your-run-directory>/.\n";
   print "> cd /<where-you-want>/<your-run-directory>/\n";
   print "# specify var names which you want to visualize in problem.par file \n";
   print "> ./piernik or >mpirun -n <np> ./piernik\n";
   print "!===================================================================================!\n";
   print "# there is also one script to do all these things above at once:\n";
   print "> setup <problem>\n";
   print " \n";
} elsif ($ARGV[0] eq "arrays"){
   print " \n";
   print "u(nu,nx,ny,nz) - fluid quantity array: nu - number of quantities like density,\n";
   print "                 momentum, energy; nx,ny,nz - number of cells in each direction;\n";
   print "idna           - density u-array-position index array of all fluids;\n";
   print "imxa,imya,imza - x,y,z-component of momentum u-array-position index of all fluids;\n";
   print "iena,iecr      - energy of adiabatic fluids and CR anargy u-array-position indexes;\n";
   print "nfluid,nadiab,nmagn - number of all, adiabatic and magnetized fluids;\n";
   print "fadiab,fmagn   - arrays of numbers of adiabatic and magnetized fluids;\n";
   print "#ifdef ISO     - all fluids are isothermal, there is no iena position in u array;\n";
   print "#ifndef ISO    - only DUST fluids are isothermal, other fluids are adiabatic.\n";
   print " \n";
} elsif ($ARGV[0] eq "hdf"){
   print " \n";
   print " use plot_mhd.pro routines in ./pro directory to visualize results from hdf files:\n";
   print " use following var's:\n";
   print " den1,den2... - densities of first and next fluids;\n";
   print " vlx1,vly2... - x,y,z-components of velocity of different fluids;\n";
   print " vou1,vrt2... - radial and rotational (azimutal) components of velocity;\n";
   print " ene1,ein2... - energy and internal energy;\n";
   print " magx,magy,magz - x,y,z-components of magnetic field.\n";
   print " Some of them you should insert into problem.par file before runing the simulation.\n";
   print " In problem.par var names could be a bit different: dens, velx, vely, velz, ener, eint.\n";
   print " Do not specify names for each fluid.\n";
   print " \n";
} else {
open MAKEIN, "< compilers/default.in" or die $!;
@makein = <MAKEIN>;
close MAKEIN;
rmtree(['obj']);
mkpath(['obj']);
$probdir = "problems/". $ARGV[0] . "/";
if(!-r $probdir) { die "Can't open $probdir: $!";}

@prob = ( "../" . $probdir . "init_problem.F90",
          "../" . $probdir . "problem.par" );
@base = <src/base/*.F90>;
@fludef = ();
for (@base) {
   s/src/\.\.\/src/;
}
@addons = ();
copy("compilers/newcompiler","obj/newcompiler");
system("chmod a+x obj/newcompiler");
$defs = $probdir."piernik.def";
copy($defs,"obj/piernik.def");
open (defs) or die "Can't open the file piernik.def!";
@fdefs = <defs>;
@d = grep (/define/,@fdefs);
if( grep { /IONIZED/} @d) {
   push(@addons, "../src/fluidbase/ionizeds.F90");
   push(@fludef, "../src/fluidbase/arrions.def");
}
if( grep { /NEUTRAL/} @d) {
   push(@addons, "../src/fluidbase/neutrals.F90");
   push(@fludef, "../src/fluidbase/arrneut.def");
}
if( grep { /MOLECULAR/} @d) {
   push(@addons, "../src/fluidbase/moleculars.F90");
   push(@fludef, "../src/fluidbase/arrmols.def");
}
if( grep { /DUST/} @d) {
   push(@addons, "../src/fluidbase/dusts.F90");
   push(@fludef, "../src/fluidbase/arrdust.def");
}
if( grep { /COSM_RAYS/} @d) {
   push(@addons, "../src/fluidbase/cosmic_rays.F90");
   push(@addons, "../src/cosm_rays/cr_diffusion.F90");
   push(@fludef, "../src/fluidbase/arrcray.def");
}
  push(@fludef, "../src/base/datalogshort.def");
  push(@fludef, "../src/base/dataloglong.def");
if( grep { /GRAV/ }  @d) {
   push(@addons, "../src/gravity/gravity.F90");
   push(@addons, "../src/gravity/hydrostatic.F90");
   }
if( grep { /SELF_GRAV/ }  @d) {push(@addons, "../src/gravity/poisson_solver.F90");}
if( grep { /RESIST/} @d) {push(@addons, "../src/resist/resistivity.F90");}
if( grep { /SHEAR/}  @d) {push(@addons, "../src/shear/shear.F90");}
if( grep { /HDF5/}  @d) {push(@addons, "../src/hdf5/dataio_hdf5.F90");}
if( grep { /SN_SRC/} @d) {
   push(@addons, "../src/supernovae/sn_sources.F90");
}
if( grep { /SNE_DISTR/} @d) {
   push(@addons, "../src/supernovae/sn_distr.F90");
}
push(@addons, "../src/scheme/both/advects.F90");
push(@addons, "../src/scheme/both/fluids.F90");
push(@addons, "../src/scheme/both/tv.F90");
push(@addons, "../src/fluidbase/allfluxes.F90");
if( grep { /ANY_SOURCES/} @d) {
push(@addons, "../src/fluidbase/allsources.F90");
}
if( grep { /ANY_LIMITS/} @d) {
push(@addons, "../src/fluidbase/floor_ceil.F90");
}
if( grep { /UNSPLIT_1D/ } @d) {
   push(@addons, "../src/scheme/unsplit/1D/mhdstep.F90");
} elsif( grep { /UNSPLIT_3D/ } @d) {
   push(@addons, "../src/scheme/unsplit/3D/mhdstep.F90");
} else {
   push(@addons, "../src/scheme/split/mhdstep.F90");
}
@files = ( @base, @prob, @addons, @fludef );
@symln = ();
foreach $file (@files) {
   $pos = rindex($file,"\/")+1;
   $len = length($file);
   push(@symln,"obj/".substr($file,$pos,$len-$pos) );
}
for $i (0 .. $#symln){
  symlink($files[$i],$symln[$i]);
}
chdir 'obj';
open(MAKEFILE, "> Makefile-prep");

# Source listing
#
#print MAKEFILE @makein;
#foreach $line (@makein){
#   print "$line";
#}
print MAKEFILE "SRCS =\t";
@srcs = <*.F90>;
&PrintWords(8, 0, @srcs);
print MAKEFILE "\n\n";
#
# Object listing
#
print MAKEFILE "OBJS =\t";
@objs = @srcs;
foreach (@objs) { s/\.[^.]+$/.o/ };
&PrintWords(8, 0, @objs);
print MAKEFILE "\n\n";
#
# Define common macros
#
print MAKEFILE "LIBS = -L\$(HDF_LIB) -L\${MHDF_LIB} -lmfhdf -ldf -ljpeg -lz\n\n";
#
# make
#
print MAKEFILE "all: date \$(PROG) \n\n";
print MAKEFILE "\$(PROG): \$(OBJS)\n";
print MAKEFILE "\t\$(", &LanguageCompiler($ARGV[1], @srcs);
print MAKEFILE ") \$(LDFLAGS) -o \$@ \$(OBJS) \$(LIBS)\n\n";
#
# make date
#
print MAKEFILE "date: \n";
print MAKEFILE "\trm -f env.*\n";
print MAKEFILE "\tcp ../src/base/env.F90 .\n";
print MAKEFILE "\thead -n 1 *.F90 | grep Id > env.dat\n";
print MAKEFILE "\tcat piernik.def >> env.dat\n";
print MAKEFILE "\twc -l env.dat | awk '{print \"\tinteger, parameter :: nenv = \"\$\$1\"+1\"}' - >> env.F90\n";
print MAKEFILE "\techo \"   character*128, dimension(nenv) :: env = (/ &\" >> env.F90\n";
print MAKEFILE "\tawk '{printf(\"\\t\\t \\\" %s \\\" ,&\\n\",\$\$0)}' env.dat >> env.F90\n";
print MAKEFILE "\techo '      \" \" /)' >> env.F90\n";
print MAKEFILE "\techo 'end module comp_log' >> env.F90\n\n";

#
# make clean
#
print MAKEFILE "clean:\n";
print MAKEFILE "\trm -f \$(PROG) \$(OBJS) *.mod\n\n";
#
# make clean-run
#
print MAKEFILE "clean-run:\n";
print MAKEFILE "\trm -f *.bck *~ *.hdf *.res *.log *.tsl *.out *.tmp core*\n\n";
#
# make clean-all
#
print MAKEFILE "clean-all:\n";
print MAKEFILE "\trm -f \$(PROG) \$(OBJS) *.mod *.bck *~ *.hdf *.res *.log *.tsl *.out *.tmp core* *.f *.dbg \n\n";
#
# Make .F90 a valid suffix
#
print MAKEFILE ".SUFFIXES: \$(SUFFIXES) .F90\n\n";
#
# .F90 -> .o
#
print MAKEFILE ".F90.o:\n";
print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c \$<\n\n";
#
# override the built-in rule for .mod (Modula-2 source code files)
#
print MAKEFILE "%.o : %.mod\n\n";
#
# Dependency listings
#
&MakeDependsf90($ARGV[1]);
&MakeDepends("*.f *.F *.F90", '^\s*use\s+["\']([^"\']+)["\']');
&MakeDepends("*.c",     '^\s*#\s*include\s+["\']([^"\']+)["\']');

system("./post","mhd",$ARGV[0]);
system("./newcompiler Makefile");
}
}

#
# &PrintWords(current output column, extra tab?, word list); --- print words
#    nicely
#
sub PrintWords {
   local($columns) = 78 - shift(@_);
   local($extratab) = shift(@_);
   local($wordlength);
   #
   print MAKEFILE @_[0];
   $columns -= length(shift(@_));
   foreach $word (@_) {
      $wordlength = length($word);
      if ($wordlength + 1 < $columns) {
         print MAKEFILE " $word";
         $columns -= $wordlength + 1;
         }
      else {
         #
         # Continue onto a new line
         #
         if ($extratab) {
            print MAKEFILE " \\\n\t\t$word";
            $columns = 62 - $wordlength;
            }
         else {
            print MAKEFILE " \\\n\t$word";
            $columns = 70 - $wordlength;
            }
         }
      }
   }

#
# &LanguageCompiler(compiler, sources); --- determine the correct language
#    compiler
#
sub LanguageCompiler {
   local($compiler) = &toLower(shift(@_));
   local(@srcs) = @_;
   #
   if (length($compiler) > 0) {
      CASE: {
         grep(/^$compiler$/, ("fc", "f77")) &&
            do { $compiler = "FC"; last CASE; };
         grep(/^$compiler$/, ("cc", "c"))   &&
            do { $compiler = "CC"; last CASE; };
         $compiler = "F90";
         }
      }
   else {
      CASE: {
         grep(/\.F90$/, @srcs)   && do { $compiler = "F90"; last CASE; };
         grep(/\.(f|F)$/, @srcs) && do { $compiler = "FC";  last CASE; };
         grep(/\.c$/, @srcs)     && do { $compiler = "CC";  last CASE; };
         $compiler = "???";
         }
      }
   $compiler;
   }

#
# &toLower(string); --- convert string into lower case
#
sub toLower {
   local($string) = @_[0];
   $string =~ tr/A-Z/a-z/;
   $string;
   }

#
# &uniq(sorted word list); --- remove adjacent duplicate words
#
sub uniq {
   local(@words);
   foreach $word (@_) {
      if ($word ne $words[$#words]) {
         push(@words, $word);
         }
      }
   @words;
   }

#
# &MakeDepends(language pattern, include file sed pattern); --- dependency
#    maker
#
sub MakeDepends {
   local(@incs);
   local($lang) = @_[0];
   local($pattern) = @_[1];
   #
   foreach $file (<${lang}>) {
      open(FILE, $file) || warn "Cannot open $file: $!\n";
      while (<FILE>) {
         /$pattern/i && push(@incs, $1);
         }
      if (defined @incs) {
         $file =~ s/\.[^.]+$/.o/;
         print MAKEFILE "$file: ";
         &PrintWords(length($file) + 2, 0, @incs);
         print MAKEFILE "\n";
         undef @incs;
         }
      }
   }

#
# &MakeDependsf90(f90 compiler); --- FORTRAN 90 dependency maker
#
sub MakeDependsf90 {
   local($compiler) = &toLower(@_[0]);
   local(@dependencies);
   local(%filename);
   local(@incs);
   local(@modules);
   local($objfile);
   #
   # Associate each module with the name of the file that contains it
   #
   foreach $file (<*.F90>) {
      open(FILE, $file) || warn "Cannot open $file: $!\n";
      while (<FILE>) {
         /^\s*module\s+([^\s!]+)/i &&
            ($filename{&toLower($1)} = $file) =~ s/\.F90$/.o/;
         }
      }
   #
   # Print the dependencies of each file that has one or more include's or
   # references one or more modules
   #
   foreach $file (<*.F90>) {
      open(FILE, $file);
      while (<FILE>) {
#         /^\s*include\s+["\']([^"\']+)["\']/i && push(@incs, $1);
         /^\s*use\s+([^\s,!]+)/i && push(@modules, &toLower($1));
         }
      if (defined @incs || defined @modules) {
         ($objfile = $file) =~ s/\.F90$/.o/;
         print MAKEFILE "$objfile: $file ";
         undef @dependencies;
         foreach $module (@modules) {
            push(@dependencies, $filename{$module});
            }
         @dependencies = &uniq(sort(@dependencies));
         &PrintWords(length($objfile) + 2, 0,
                     @dependencies, &uniq(sort(@incs)));
         print MAKEFILE "\n";
         undef @incs;
         undef @modules;
         #
         # Cray F90 compiler
         #
         if ($compiler eq "cray") {
            print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
            foreach $depend (@dependencies) {
               push(@modules, "-p", $depend);
               }
            push(@modules, $file);
            &PrintWords(30, 1, @modules);
            print MAKEFILE "\n";
            undef @modules;
            }
         #
         # ParaSoft F90 compiler
         #
         if ($compiler eq "parasoft") {
            print MAKEFILE "\t\$(F90) \$(F90FLAGS) -c ";
            foreach $depend (@dependencies) {
               $depend =~ s/\.o$/.F90/;
               push(@modules, "-module", $depend);
               }
            push(@modules, $file);
            &PrintWords(30, 1, @modules);
            print MAKEFILE "\n";
            undef @modules;
            }
         }
      }
   }
