!
! PIERNIK Code Copyright (C) 2006 Michal Hanasz
!
!    This file is part of PIERNIK code.
!
!    PIERNIK is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    PIERNIK is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with PIERNIK.  If not, see <http://www.gnu.org/licenses/>.
!
!    Initial implementation of PIERNIK code was based on TVD split MHD code by
!    Ue-Li Pen
!        see: Pen, Arras & Wong (2003) for algorithm and
!             http://www.cita.utoronto.ca/~pen/MHD
!             for original source code "mhd.f90"
!
!    For full list of developers see $PIERNIK_HOME/license/pdt.txt
!
#include "piernik.h"
#define RNG is:ie, js:je, ks:ke
module initproblem

! Initial condition for Sedov-Taylor explosion
! Written by: M. Hanasz, March 2006

   implicit none

   private
   public  :: read_problem_par, problem_initial_conditions, problem_pointers

   integer(kind=4) :: n_sn
   real            :: d0, p0, bx0, by0, bz0, Eexpl, x0, y0, z0, r0, dt_sn, r, t_sn
   

   namelist /PROBLEM_CONTROL/ d0, p0, bx0, by0, bz0, Eexpl, x0, y0, z0, r0, n_sn, dt_sn

contains
!-----------------------------------------------------------------------------
   subroutine problem_pointers

      implicit none
      


   end subroutine problem_pointers
!-----------------------------------------------------------------------------
   subroutine read_problem_par

      implicit none

      !call print_essential_units


   end subroutine read_problem_par
!-----------------------------------------------------------------------------
   subroutine problem_initial_conditions

      use cg_leaves,      only: leaves
      use cg_list,        only: cg_list_element
      use constants,      only: xdim, ydim, zdim, LO, HI
      use dataio_pub,     only: printinfo
      use fluidindex,     only: flind
      use particle_pub,   only: pset
      use particle_types, only: ht_integrator
      
      
      !use particles_io_hdf5

      implicit none

      integer                         :: i, j, k, p
      integer                         :: n_particles        !< number of particles
      real(kind=4)                    :: e                  !< orbit eccentricity
      logical,save                    :: first_run = .true.
      character(len=2)                :: plane
      type(cg_list_element), pointer  :: cgl
      
    
      do p = lbound(flind%all_fluids, dim=1), ubound(flind%all_fluids, dim=1)
         cgl => leaves%first
         do while (associated(cgl))
            associate(cg => cgl%cg)
               do k = cg%lhn(zdim,LO), cg%lhn(zdim,HI)
                  do j = cg%lhn(ydim,LO), cg%lhn(ydim,HI)
                     do i = cg%lhn(xdim,LO), cg%lhn(xdim,HI)
                        associate( fl => flind%all_fluids(p)%fl )
                           cg%u(fl%idn,i,j,k) = 1.0
                           cg%u(fl%imx,i,j,k) = 0.0
                           cg%u(fl%imy,i,j,k) = 0.0
                           cg%u(fl%imz,i,j,k) = 0.0
                        end associate
                     enddo
                  enddo
               enddo
            end associate
            cgl => cgl%nxt
         enddo
      enddo



      if (ht_integrator) then
         if(first_run) then
            call pset%add(1.0, [ 0.9700436, -0.24308753, 0.0], [ 0.466203685, 0.43236573, 0.0],0.0)
            call pset%add(1.0, [-0.9700436, 0.24308753, 0.0], [ 0.466203685, 0.43236573, 0.0],0.0)
            call pset%add(1.0, [ 0.0, 0.0, 0.0], [-0.932407370, -0.86473146, 0.0], 0.0 )
         endif
         first_run=.false.
      else
         e = 0.6
         n_particles = 1
         plane = 'XY'
         !call orbits(n_particles, e, first_run, plane)
         call relax_time(n_particles, first_run)
         !call read_buildgal
      endif


      contains

!< \brief rotate (x,y,z) vector by an angle theta

      function positions(dtheta, pos_init, plane)
         implicit none
            real, dimension(3) :: positions, pos_init
            real :: dtheta
            character(len=2) :: plane
               positions = rotate(dtheta, pos_init, plane)
      end function positions

!<
!! \brief compute velocity of particle
!!
!! \details compute velocity of particle with position pos_init and eccentricity e <0,1)
!!
!! \warning it works properly only in XY plane 
!>

      function velocities(pos_init, e)
         use constants,             only: zero, one, dpi
         use dataio_pub,            only: die
         use units,                 only: newtong
         implicit none
            real, dimension(3)  :: pos_init, velocities
            real                 :: a        !< semi-major axis of initial elliptical orbit of particle
            real                 :: r        !< lenght of radius vector
            real(kind=4)         :: e
            real                 :: mu
            real, parameter     :: M=1.0
            real:: lenght  !usunac
            
            mu = newtong*M

            if( (e < zero) .or. (e >= one) ) then
               call die("[initproblem:velocities] Invalid eccentricity")
            else
               r = sqrt(pos_init(1)**2 + pos_init(2)**2 + pos_init(3)**2)

               if (e == real(0.0,4)) then
                  velocities(2) = sqrt(mu/r)
                  write(*,*) "Orbita kolowa"
               else
                  a = r/(1.0 + e)
                  velocities(2) = sqrt(mu*(2.0/r - 1.0/a))
                  write(*,'(A11,F4.2,A3,F5.3,A3,F5.3)') "#Elipsa: e=", e, " a=",a, " b=", a*sqrt(1.0 - e**2)
                  lenght = dpi*sqrt((a**3)/mu)  !usunac 
                  write(*,*) "lenght=", lenght
               endif
            endif
            velocities(1) = 0.0
            velocities(3) = 0.0
      end function velocities

!< 
!! \brief rotate vector over one of the axes by an angle theta
!!
!! \todo add to selection of axis (next variable)
!>
      function rotate (theta, vector, plane)
         implicit none
            real, dimension(3) :: vector, rotate
            real :: theta
            character(len=2) :: plane
            
            select case (plane)
               case('XY', 'YX', 'xy', 'yx')
                  rotate(1) = vector(1)*cos(theta) - vector(2)*sin(theta)
                  rotate(2) = vector(1)*sin(theta) + vector(2)*cos(theta)
                  rotate(3) = vector(3)
               case('XZ', 'ZX', 'xz', 'zx')
                  rotate(1) = vector(1)*cos(theta) - vector(3)*sin(theta)
                  rotate(2) = vector(2)
                  rotate(3) = vector(1)*sin(theta) + vector(3)*cos(theta)
               case('YZ', 'ZY', 'yz', 'zy')
                  rotate(1) = vector(1)
                  rotate(2) = vector(2)*cos(theta) - vector(3)*sin(theta)
                  rotate(3) = vector(2)*sin(theta) + vector(3)*cos(theta)
            end select

      end function rotate


      subroutine orbits(n_particles, e, first_run, plane)
         use particle_pub, only: pset
         use constants,    only: dpi
         implicit none
         integer,intent(in)            :: n_particles
         real(kind=4),intent(in)       :: e
         real,dimension(3)             :: pos_init, vel_init
         real                           :: dtheta
         !real,parameter                :: pi2=6.283185307
         logical,intent(inout)         :: first_run
         character(len=2), intent(in) :: plane
         
         write(*,*) "Number of particles: ", n_particles
         
         dtheta = dpi/n_particles


         pos_init(1) = 2.0
         pos_init(2) = 0.0
         pos_init(3) = 0.0

         vel_init = velocities(pos_init, e)
         write(*,*) "vel_init", vel_init

         if(first_run) then
            !call pset%add(1.1, [ 0.9700436, -0.24308753, 0.0], [ 0.466203685, 0.43236573, 0.0])
            !call pset%add(1.1, [-0.9700436, 0.24308753, 0.0], [ 0.466203685, 0.43236573, 0.0],0.0)
            !call pset%add(1.1, [ 0.0, 0.0, 0.0], [-0.932407370, -0.86473146, 0.0], 0.0 )
            do i = 1, n_particles, 1
               call pset%add(1.0, pos_init, vel_init,0.0 ) !orbita eliptyczna
               !call pset%add(1.0, [4.54545454545455, 0.0, 0.0],[-0.909090909090909, 0.0, 0.0], 0.0)

               pos_init = positions(dtheta, pos_init, plane)
               vel_init = rotate(dtheta, vel_init, plane)
            enddo

            !call pset%add(100.0, [0.0,0.0,0.0],[0.0,0.0,0.0],0.0)
            !call pset%add(0.1, [3.0,0.0,0.0],[0.0,0.0,0.0],0.0)
           
            first_run = .false.
            
            write(*,*) "Obliczono pozycje czastek "
         endif
      end subroutine orbits



!< \brief create a set of particles in random positions inside a sphere

      subroutine relax_time(n_particles, first_run)
         use particle_pub, only: pset
#ifdef HDF5
         use particles_io_hdf5, only: write_hdf5, read_hdf5
#endif /* HDF5 */

         implicit none

         integer                          :: i, j
         integer, parameter              :: seed = 86437
         integer, intent(in)             :: n_particles
         logical, intent(inout)          :: first_run

         real, dimension(n_particles, 3) :: pos_init!, pos_init2!,vel_init
         real, dimension(3, 2)           :: domain

         real                             :: factor, r_dom
         real, parameter                 :: onesixth = 1.0/6.0

#ifdef HDF5
         real, dimension(n_particles, 3) :: pos2hdf5!, vel2hdf5
#endif /* HDF5 */
         
         domain(1,1) = -5.0
         domain(2,1) = -5.0
         domain(3,1) = -5.0
         domain(1,2) = 5.0
         domain(2,2) = 5.0
         domain(3,2) = 5.0

         write(*,*) "Number of particles: ", n_particles

         call srand(seed)
         r_dom = onesixth*sqrt(domain(1,2)**2 + domain(2,2)**2 + domain(3,2)**2)


         if(first_run) then
            do i = 1, n_particles
               r = r_dom
               do while ((r>=r_dom))
                  do j = 1, 3
                     factor = rand(0)
                     pos_init(i, j) = sign(rand(0)*domain(j, 2),factor-0.5)
                  enddo
                  r = sqrt(pos_init(i,1)**2 + pos_init(i,2)**2 + pos_init(i,3)**2)
               enddo
#ifdef HDF5
               pos2hdf5(i, :) = pos_init(i,:)
#endif /* HDF5 */
               call pset%add(1.0, pos_init(i,:), [0.0,0.0,0.0],0.0 )
            enddo
            first_run = .false.
            write(*,*) "Obliczono pozycje czastek"
#ifdef HDF5
            call write_hdf5(pos_init, n_particles)
            !call read_hdf5(pos_init2, n_particles)
#endif /* HDF5 */
         endif

      end subroutine relax_time

   end subroutine problem_initial_conditions


      subroutine print_essential_units

      use dataio_pub, only: msg, printinfo
      use mpisetup,   only: master
      use units,      only: units_set, s_len_u, s_time_u, s_mass_u, miu0, km, au, lyr, mH, gmu, erg, eV, clight, Gs, mGs, cm, ppcm2, ppcm3

      implicit none

      if (master) then

         call printinfo('VINE to PIERNIK convertion of units done:')
         write(msg,'(a,a28       )') units_set, ' is used in this simulation.'                         ; call printinfo(msg)
         write(msg,'(a16,3a      )') 'It is based on: ', trim(s_len_u), trim(s_time_u), trim(s_mass_u) ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') '                       miu0 = ', miu0                            ; call printinfo(msg)
         call printinfo('Some essential units for this set:')
         write(msg,'(a30,e22.15,a)') '                         km = ', km, s_len_u                     ; call printinfo(msg)
         write(msg,'(a30,e22.15,a)') '                         AU = ', au, s_len_u                     ; call printinfo(msg)
         write(msg,'(a30,e22.15,a)') '                        lyr = ', lyr, s_len_u                    ; call printinfo(msg)
         write(msg,'(a30,e22.15,a)') 'hydrogen atom mass:      mH = ', mH, s_mass_u                    ; call printinfo(msg)
         write(msg,'(a30,e22.15,a)') 'galactic mass unit:     gmu = ', gmu, s_mass_u                   ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') '    hydrogen atoms / cm2    = ', mH/cm**2                        ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') '    hydrogen atoms / cm3    = ', mH/cm**3                        ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') 'averaged particles / cm2    = ', ppcm2                           ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') 'averaged particles / cm3    = ', ppcm3                           ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') '                        erg = ', erg                             ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') '                         eV = ', eV                              ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') '                  erg / cm3 = ', erg/cm**3                       ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') '                   eV / cm3 = ', eV/cm**3                        ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') 'speed of light in vacuum: c = ', clight                          ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') 'magnetic induction unit: Gs = ', Gs                              ; call printinfo(msg)
         write(msg,'(a30,e22.15  )') '                    microGs = ', mGs                            ; call printinfo(msg)
         
         write(msg,*) '                    rho = ',  cm**3/mH                           ; call printinfo(msg)
      endif

   end subroutine print_essential_units



   subroutine read_buildgal
      use particle_pub, only: pset
      implicit none
      integer :: i, j, nbodies, dims=3
      integer :: galfile=1
      character(len=6) :: galname="SPIRAL"
      real,dimension(:,:), allocatable :: pos, vel
      real,dimension(:), allocatable :: mass

      open(unit=galfile,file=galname,action="read",status="old")
         read(galfile,*) nbodies
         write(*,*) "nbodies=",nbodies

         allocate(mass(nbodies),pos(nbodies,3),vel(nbodies,3))

         read(galfile,*) (mass(i),i=1,nbodies), &
         ((pos(i,j),j=1,dims),i=1,nbodies),&
         ((vel(i,j),j=1,dims),i=1,nbodies)

      close(galfile)
      
      open(unit=2,file='galtest.dat')
         do i=1,nbodies
         if (modulo(i, 1000) .eq. 0.0) then
            write(*,*) i
         endif
            call pset%add(mass(i), pos(i,:), vel(i,:),0.0)
         enddo
      close(2)

   end subroutine read_buildgal

!-----------------------------------------------------------------------------
end module initproblem
